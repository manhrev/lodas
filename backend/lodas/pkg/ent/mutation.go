// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/manhrev/lodas/backend/lodas/pkg/ent/betsetting"
	"github.com/manhrev/lodas/backend/lodas/pkg/ent/predicate"
	"github.com/manhrev/lodas/backend/lodas/pkg/ent/record"
	"github.com/manhrev/lodas/backend/lodas/pkg/ent/result"
	"github.com/manhrev/lodas/backend/lodas/pkg/ent/schema"
	"github.com/manhrev/lodas/backend/lodas/pkg/ent/sheet"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBetSetting = "BetSetting"
	TypeRecord     = "Record"
	TypeResult     = "Result"
	TypeSheet      = "Sheet"
)

// BetSettingMutation represents an operation that mutates the BetSetting nodes in the graph.
type BetSettingMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	user_id       *int64
	adduser_id    *int64
	values        **schema.BetSettingMap
	created_time  *time.Time
	clearedFields map[string]struct{}
	sheets        map[int64]struct{}
	removedsheets map[int64]struct{}
	clearedsheets bool
	done          bool
	oldValue      func(context.Context) (*BetSetting, error)
	predicates    []predicate.BetSetting
}

var _ ent.Mutation = (*BetSettingMutation)(nil)

// betsettingOption allows management of the mutation configuration using functional options.
type betsettingOption func(*BetSettingMutation)

// newBetSettingMutation creates new mutation for the BetSetting entity.
func newBetSettingMutation(c config, op Op, opts ...betsettingOption) *BetSettingMutation {
	m := &BetSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeBetSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBetSettingID sets the ID field of the mutation.
func withBetSettingID(id int64) betsettingOption {
	return func(m *BetSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *BetSetting
		)
		m.oldValue = func(ctx context.Context) (*BetSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BetSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBetSetting sets the old BetSetting of the mutation.
func withBetSetting(node *BetSetting) betsettingOption {
	return func(m *BetSettingMutation) {
		m.oldValue = func(context.Context) (*BetSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BetSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BetSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BetSetting entities.
func (m *BetSettingMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BetSettingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BetSettingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BetSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *BetSettingMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BetSettingMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the BetSetting entity.
// If the BetSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetSettingMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *BetSettingMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *BetSettingMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BetSettingMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetValues sets the "values" field.
func (m *BetSettingMutation) SetValues(ssm *schema.BetSettingMap) {
	m.values = &ssm
}

// Values returns the value of the "values" field in the mutation.
func (m *BetSettingMutation) Values() (r *schema.BetSettingMap, exists bool) {
	v := m.values
	if v == nil {
		return
	}
	return *v, true
}

// OldValues returns the old "values" field's value of the BetSetting entity.
// If the BetSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetSettingMutation) OldValues(ctx context.Context) (v *schema.BetSettingMap, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValues: %w", err)
	}
	return oldValue.Values, nil
}

// ResetValues resets all changes to the "values" field.
func (m *BetSettingMutation) ResetValues() {
	m.values = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *BetSettingMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *BetSettingMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the BetSetting entity.
// If the BetSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BetSettingMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *BetSettingMutation) ResetCreatedTime() {
	m.created_time = nil
}

// AddSheetIDs adds the "sheets" edge to the Sheet entity by ids.
func (m *BetSettingMutation) AddSheetIDs(ids ...int64) {
	if m.sheets == nil {
		m.sheets = make(map[int64]struct{})
	}
	for i := range ids {
		m.sheets[ids[i]] = struct{}{}
	}
}

// ClearSheets clears the "sheets" edge to the Sheet entity.
func (m *BetSettingMutation) ClearSheets() {
	m.clearedsheets = true
}

// SheetsCleared reports if the "sheets" edge to the Sheet entity was cleared.
func (m *BetSettingMutation) SheetsCleared() bool {
	return m.clearedsheets
}

// RemoveSheetIDs removes the "sheets" edge to the Sheet entity by IDs.
func (m *BetSettingMutation) RemoveSheetIDs(ids ...int64) {
	if m.removedsheets == nil {
		m.removedsheets = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.sheets, ids[i])
		m.removedsheets[ids[i]] = struct{}{}
	}
}

// RemovedSheets returns the removed IDs of the "sheets" edge to the Sheet entity.
func (m *BetSettingMutation) RemovedSheetsIDs() (ids []int64) {
	for id := range m.removedsheets {
		ids = append(ids, id)
	}
	return
}

// SheetsIDs returns the "sheets" edge IDs in the mutation.
func (m *BetSettingMutation) SheetsIDs() (ids []int64) {
	for id := range m.sheets {
		ids = append(ids, id)
	}
	return
}

// ResetSheets resets all changes to the "sheets" edge.
func (m *BetSettingMutation) ResetSheets() {
	m.sheets = nil
	m.clearedsheets = false
	m.removedsheets = nil
}

// Where appends a list predicates to the BetSettingMutation builder.
func (m *BetSettingMutation) Where(ps ...predicate.BetSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BetSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BetSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BetSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BetSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BetSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BetSetting).
func (m *BetSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BetSettingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user_id != nil {
		fields = append(fields, betsetting.FieldUserID)
	}
	if m.values != nil {
		fields = append(fields, betsetting.FieldValues)
	}
	if m.created_time != nil {
		fields = append(fields, betsetting.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BetSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case betsetting.FieldUserID:
		return m.UserID()
	case betsetting.FieldValues:
		return m.Values()
	case betsetting.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BetSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case betsetting.FieldUserID:
		return m.OldUserID(ctx)
	case betsetting.FieldValues:
		return m.OldValues(ctx)
	case betsetting.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown BetSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BetSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case betsetting.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case betsetting.FieldValues:
		v, ok := value.(*schema.BetSettingMap)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValues(v)
		return nil
	case betsetting.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown BetSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BetSettingMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, betsetting.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BetSettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case betsetting.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BetSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case betsetting.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown BetSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BetSettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BetSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BetSettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BetSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BetSettingMutation) ResetField(name string) error {
	switch name {
	case betsetting.FieldUserID:
		m.ResetUserID()
		return nil
	case betsetting.FieldValues:
		m.ResetValues()
		return nil
	case betsetting.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown BetSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BetSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sheets != nil {
		edges = append(edges, betsetting.EdgeSheets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BetSettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case betsetting.EdgeSheets:
		ids := make([]ent.Value, 0, len(m.sheets))
		for id := range m.sheets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BetSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsheets != nil {
		edges = append(edges, betsetting.EdgeSheets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BetSettingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case betsetting.EdgeSheets:
		ids := make([]ent.Value, 0, len(m.removedsheets))
		for id := range m.removedsheets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BetSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsheets {
		edges = append(edges, betsetting.EdgeSheets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BetSettingMutation) EdgeCleared(name string) bool {
	switch name {
	case betsetting.EdgeSheets:
		return m.clearedsheets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BetSettingMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BetSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BetSettingMutation) ResetEdge(name string) error {
	switch name {
	case betsetting.EdgeSheets:
		m.ResetSheets()
		return nil
	}
	return fmt.Errorf("unknown BetSetting edge %s", name)
}

// RecordMutation represents an operation that mutates the Record nodes in the graph.
type RecordMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	numbers        *[]string
	appendnumbers  []string
	cash_amount    *int64
	addcash_amount *int64
	bet_type       *int64
	addbet_type    *int64
	prize          *[]int
	appendprize    []int
	cash_in        *int64
	addcash_in     *int64
	cash_out       *int64
	addcash_out    *int64
	created_time   *time.Time
	win_info       **schema.PrizeMap
	clearedFields  map[string]struct{}
	sheet          *int64
	clearedsheet   bool
	done           bool
	oldValue       func(context.Context) (*Record, error)
	predicates     []predicate.Record
}

var _ ent.Mutation = (*RecordMutation)(nil)

// recordOption allows management of the mutation configuration using functional options.
type recordOption func(*RecordMutation)

// newRecordMutation creates new mutation for the Record entity.
func newRecordMutation(c config, op Op, opts ...recordOption) *RecordMutation {
	m := &RecordMutation{
		config:        c,
		op:            op,
		typ:           TypeRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecordID sets the ID field of the mutation.
func withRecordID(id int64) recordOption {
	return func(m *RecordMutation) {
		var (
			err   error
			once  sync.Once
			value *Record
		)
		m.oldValue = func(ctx context.Context) (*Record, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Record.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecord sets the old Record of the mutation.
func withRecord(node *Record) recordOption {
	return func(m *RecordMutation) {
		m.oldValue = func(context.Context) (*Record, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Record entities.
func (m *RecordMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Record.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNumbers sets the "numbers" field.
func (m *RecordMutation) SetNumbers(s []string) {
	m.numbers = &s
	m.appendnumbers = nil
}

// Numbers returns the value of the "numbers" field in the mutation.
func (m *RecordMutation) Numbers() (r []string, exists bool) {
	v := m.numbers
	if v == nil {
		return
	}
	return *v, true
}

// OldNumbers returns the old "numbers" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldNumbers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumbers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumbers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumbers: %w", err)
	}
	return oldValue.Numbers, nil
}

// AppendNumbers adds s to the "numbers" field.
func (m *RecordMutation) AppendNumbers(s []string) {
	m.appendnumbers = append(m.appendnumbers, s...)
}

// AppendedNumbers returns the list of values that were appended to the "numbers" field in this mutation.
func (m *RecordMutation) AppendedNumbers() ([]string, bool) {
	if len(m.appendnumbers) == 0 {
		return nil, false
	}
	return m.appendnumbers, true
}

// ResetNumbers resets all changes to the "numbers" field.
func (m *RecordMutation) ResetNumbers() {
	m.numbers = nil
	m.appendnumbers = nil
}

// SetCashAmount sets the "cash_amount" field.
func (m *RecordMutation) SetCashAmount(i int64) {
	m.cash_amount = &i
	m.addcash_amount = nil
}

// CashAmount returns the value of the "cash_amount" field in the mutation.
func (m *RecordMutation) CashAmount() (r int64, exists bool) {
	v := m.cash_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCashAmount returns the old "cash_amount" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldCashAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashAmount: %w", err)
	}
	return oldValue.CashAmount, nil
}

// AddCashAmount adds i to the "cash_amount" field.
func (m *RecordMutation) AddCashAmount(i int64) {
	if m.addcash_amount != nil {
		*m.addcash_amount += i
	} else {
		m.addcash_amount = &i
	}
}

// AddedCashAmount returns the value that was added to the "cash_amount" field in this mutation.
func (m *RecordMutation) AddedCashAmount() (r int64, exists bool) {
	v := m.addcash_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCashAmount resets all changes to the "cash_amount" field.
func (m *RecordMutation) ResetCashAmount() {
	m.cash_amount = nil
	m.addcash_amount = nil
}

// SetBetType sets the "bet_type" field.
func (m *RecordMutation) SetBetType(i int64) {
	m.bet_type = &i
	m.addbet_type = nil
}

// BetType returns the value of the "bet_type" field in the mutation.
func (m *RecordMutation) BetType() (r int64, exists bool) {
	v := m.bet_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBetType returns the old "bet_type" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldBetType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBetType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBetType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBetType: %w", err)
	}
	return oldValue.BetType, nil
}

// AddBetType adds i to the "bet_type" field.
func (m *RecordMutation) AddBetType(i int64) {
	if m.addbet_type != nil {
		*m.addbet_type += i
	} else {
		m.addbet_type = &i
	}
}

// AddedBetType returns the value that was added to the "bet_type" field in this mutation.
func (m *RecordMutation) AddedBetType() (r int64, exists bool) {
	v := m.addbet_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetBetType resets all changes to the "bet_type" field.
func (m *RecordMutation) ResetBetType() {
	m.bet_type = nil
	m.addbet_type = nil
}

// SetPrize sets the "prize" field.
func (m *RecordMutation) SetPrize(i []int) {
	m.prize = &i
	m.appendprize = nil
}

// Prize returns the value of the "prize" field in the mutation.
func (m *RecordMutation) Prize() (r []int, exists bool) {
	v := m.prize
	if v == nil {
		return
	}
	return *v, true
}

// OldPrize returns the old "prize" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldPrize(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrize: %w", err)
	}
	return oldValue.Prize, nil
}

// AppendPrize adds i to the "prize" field.
func (m *RecordMutation) AppendPrize(i []int) {
	m.appendprize = append(m.appendprize, i...)
}

// AppendedPrize returns the list of values that were appended to the "prize" field in this mutation.
func (m *RecordMutation) AppendedPrize() ([]int, bool) {
	if len(m.appendprize) == 0 {
		return nil, false
	}
	return m.appendprize, true
}

// ResetPrize resets all changes to the "prize" field.
func (m *RecordMutation) ResetPrize() {
	m.prize = nil
	m.appendprize = nil
}

// SetCashIn sets the "cash_in" field.
func (m *RecordMutation) SetCashIn(i int64) {
	m.cash_in = &i
	m.addcash_in = nil
}

// CashIn returns the value of the "cash_in" field in the mutation.
func (m *RecordMutation) CashIn() (r int64, exists bool) {
	v := m.cash_in
	if v == nil {
		return
	}
	return *v, true
}

// OldCashIn returns the old "cash_in" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldCashIn(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashIn: %w", err)
	}
	return oldValue.CashIn, nil
}

// AddCashIn adds i to the "cash_in" field.
func (m *RecordMutation) AddCashIn(i int64) {
	if m.addcash_in != nil {
		*m.addcash_in += i
	} else {
		m.addcash_in = &i
	}
}

// AddedCashIn returns the value that was added to the "cash_in" field in this mutation.
func (m *RecordMutation) AddedCashIn() (r int64, exists bool) {
	v := m.addcash_in
	if v == nil {
		return
	}
	return *v, true
}

// ResetCashIn resets all changes to the "cash_in" field.
func (m *RecordMutation) ResetCashIn() {
	m.cash_in = nil
	m.addcash_in = nil
}

// SetCashOut sets the "cash_out" field.
func (m *RecordMutation) SetCashOut(i int64) {
	m.cash_out = &i
	m.addcash_out = nil
}

// CashOut returns the value of the "cash_out" field in the mutation.
func (m *RecordMutation) CashOut() (r int64, exists bool) {
	v := m.cash_out
	if v == nil {
		return
	}
	return *v, true
}

// OldCashOut returns the old "cash_out" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldCashOut(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashOut is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashOut requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashOut: %w", err)
	}
	return oldValue.CashOut, nil
}

// AddCashOut adds i to the "cash_out" field.
func (m *RecordMutation) AddCashOut(i int64) {
	if m.addcash_out != nil {
		*m.addcash_out += i
	} else {
		m.addcash_out = &i
	}
}

// AddedCashOut returns the value that was added to the "cash_out" field in this mutation.
func (m *RecordMutation) AddedCashOut() (r int64, exists bool) {
	v := m.addcash_out
	if v == nil {
		return
	}
	return *v, true
}

// ResetCashOut resets all changes to the "cash_out" field.
func (m *RecordMutation) ResetCashOut() {
	m.cash_out = nil
	m.addcash_out = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *RecordMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *RecordMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *RecordMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetWinInfo sets the "win_info" field.
func (m *RecordMutation) SetWinInfo(sm *schema.PrizeMap) {
	m.win_info = &sm
}

// WinInfo returns the value of the "win_info" field in the mutation.
func (m *RecordMutation) WinInfo() (r *schema.PrizeMap, exists bool) {
	v := m.win_info
	if v == nil {
		return
	}
	return *v, true
}

// OldWinInfo returns the old "win_info" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldWinInfo(ctx context.Context) (v *schema.PrizeMap, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinInfo: %w", err)
	}
	return oldValue.WinInfo, nil
}

// ResetWinInfo resets all changes to the "win_info" field.
func (m *RecordMutation) ResetWinInfo() {
	m.win_info = nil
}

// SetSheetID sets the "sheet" edge to the Sheet entity by id.
func (m *RecordMutation) SetSheetID(id int64) {
	m.sheet = &id
}

// ClearSheet clears the "sheet" edge to the Sheet entity.
func (m *RecordMutation) ClearSheet() {
	m.clearedsheet = true
}

// SheetCleared reports if the "sheet" edge to the Sheet entity was cleared.
func (m *RecordMutation) SheetCleared() bool {
	return m.clearedsheet
}

// SheetID returns the "sheet" edge ID in the mutation.
func (m *RecordMutation) SheetID() (id int64, exists bool) {
	if m.sheet != nil {
		return *m.sheet, true
	}
	return
}

// SheetIDs returns the "sheet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SheetID instead. It exists only for internal usage by the builders.
func (m *RecordMutation) SheetIDs() (ids []int64) {
	if id := m.sheet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSheet resets all changes to the "sheet" edge.
func (m *RecordMutation) ResetSheet() {
	m.sheet = nil
	m.clearedsheet = false
}

// Where appends a list predicates to the RecordMutation builder.
func (m *RecordMutation) Where(ps ...predicate.Record) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Record, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Record).
func (m *RecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecordMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.numbers != nil {
		fields = append(fields, record.FieldNumbers)
	}
	if m.cash_amount != nil {
		fields = append(fields, record.FieldCashAmount)
	}
	if m.bet_type != nil {
		fields = append(fields, record.FieldBetType)
	}
	if m.prize != nil {
		fields = append(fields, record.FieldPrize)
	}
	if m.cash_in != nil {
		fields = append(fields, record.FieldCashIn)
	}
	if m.cash_out != nil {
		fields = append(fields, record.FieldCashOut)
	}
	if m.created_time != nil {
		fields = append(fields, record.FieldCreatedTime)
	}
	if m.win_info != nil {
		fields = append(fields, record.FieldWinInfo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case record.FieldNumbers:
		return m.Numbers()
	case record.FieldCashAmount:
		return m.CashAmount()
	case record.FieldBetType:
		return m.BetType()
	case record.FieldPrize:
		return m.Prize()
	case record.FieldCashIn:
		return m.CashIn()
	case record.FieldCashOut:
		return m.CashOut()
	case record.FieldCreatedTime:
		return m.CreatedTime()
	case record.FieldWinInfo:
		return m.WinInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case record.FieldNumbers:
		return m.OldNumbers(ctx)
	case record.FieldCashAmount:
		return m.OldCashAmount(ctx)
	case record.FieldBetType:
		return m.OldBetType(ctx)
	case record.FieldPrize:
		return m.OldPrize(ctx)
	case record.FieldCashIn:
		return m.OldCashIn(ctx)
	case record.FieldCashOut:
		return m.OldCashOut(ctx)
	case record.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case record.FieldWinInfo:
		return m.OldWinInfo(ctx)
	}
	return nil, fmt.Errorf("unknown Record field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case record.FieldNumbers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumbers(v)
		return nil
	case record.FieldCashAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashAmount(v)
		return nil
	case record.FieldBetType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBetType(v)
		return nil
	case record.FieldPrize:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrize(v)
		return nil
	case record.FieldCashIn:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashIn(v)
		return nil
	case record.FieldCashOut:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashOut(v)
		return nil
	case record.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case record.FieldWinInfo:
		v, ok := value.(*schema.PrizeMap)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinInfo(v)
		return nil
	}
	return fmt.Errorf("unknown Record field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecordMutation) AddedFields() []string {
	var fields []string
	if m.addcash_amount != nil {
		fields = append(fields, record.FieldCashAmount)
	}
	if m.addbet_type != nil {
		fields = append(fields, record.FieldBetType)
	}
	if m.addcash_in != nil {
		fields = append(fields, record.FieldCashIn)
	}
	if m.addcash_out != nil {
		fields = append(fields, record.FieldCashOut)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case record.FieldCashAmount:
		return m.AddedCashAmount()
	case record.FieldBetType:
		return m.AddedBetType()
	case record.FieldCashIn:
		return m.AddedCashIn()
	case record.FieldCashOut:
		return m.AddedCashOut()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case record.FieldCashAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCashAmount(v)
		return nil
	case record.FieldBetType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBetType(v)
		return nil
	case record.FieldCashIn:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCashIn(v)
		return nil
	case record.FieldCashOut:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCashOut(v)
		return nil
	}
	return fmt.Errorf("unknown Record numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Record nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecordMutation) ResetField(name string) error {
	switch name {
	case record.FieldNumbers:
		m.ResetNumbers()
		return nil
	case record.FieldCashAmount:
		m.ResetCashAmount()
		return nil
	case record.FieldBetType:
		m.ResetBetType()
		return nil
	case record.FieldPrize:
		m.ResetPrize()
		return nil
	case record.FieldCashIn:
		m.ResetCashIn()
		return nil
	case record.FieldCashOut:
		m.ResetCashOut()
		return nil
	case record.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case record.FieldWinInfo:
		m.ResetWinInfo()
		return nil
	}
	return fmt.Errorf("unknown Record field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sheet != nil {
		edges = append(edges, record.EdgeSheet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case record.EdgeSheet:
		if id := m.sheet; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsheet {
		edges = append(edges, record.EdgeSheet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecordMutation) EdgeCleared(name string) bool {
	switch name {
	case record.EdgeSheet:
		return m.clearedsheet
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecordMutation) ClearEdge(name string) error {
	switch name {
	case record.EdgeSheet:
		m.ClearSheet()
		return nil
	}
	return fmt.Errorf("unknown Record unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecordMutation) ResetEdge(name string) error {
	switch name {
	case record.EdgeSheet:
		m.ResetSheet()
		return nil
	}
	return fmt.Errorf("unknown Record edge %s", name)
}

// ResultMutation represents an operation that mutates the Result nodes in the graph.
type ResultMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	province      *int64
	addprovince   *int64
	created_time  *time.Time
	prize_map     **schema.PrizeMap
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Result, error)
	predicates    []predicate.Result
}

var _ ent.Mutation = (*ResultMutation)(nil)

// resultOption allows management of the mutation configuration using functional options.
type resultOption func(*ResultMutation)

// newResultMutation creates new mutation for the Result entity.
func newResultMutation(c config, op Op, opts ...resultOption) *ResultMutation {
	m := &ResultMutation{
		config:        c,
		op:            op,
		typ:           TypeResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResultID sets the ID field of the mutation.
func withResultID(id int64) resultOption {
	return func(m *ResultMutation) {
		var (
			err   error
			once  sync.Once
			value *Result
		)
		m.oldValue = func(ctx context.Context) (*Result, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Result.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResult sets the old Result of the mutation.
func withResult(node *Result) resultOption {
	return func(m *ResultMutation) {
		m.oldValue = func(context.Context) (*Result, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Result entities.
func (m *ResultMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResultMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResultMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Result.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProvince sets the "province" field.
func (m *ResultMutation) SetProvince(i int64) {
	m.province = &i
	m.addprovince = nil
}

// Province returns the value of the "province" field in the mutation.
func (m *ResultMutation) Province() (r int64, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the Result entity.
// If the Result object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResultMutation) OldProvince(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// AddProvince adds i to the "province" field.
func (m *ResultMutation) AddProvince(i int64) {
	if m.addprovince != nil {
		*m.addprovince += i
	} else {
		m.addprovince = &i
	}
}

// AddedProvince returns the value that was added to the "province" field in this mutation.
func (m *ResultMutation) AddedProvince() (r int64, exists bool) {
	v := m.addprovince
	if v == nil {
		return
	}
	return *v, true
}

// ResetProvince resets all changes to the "province" field.
func (m *ResultMutation) ResetProvince() {
	m.province = nil
	m.addprovince = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *ResultMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ResultMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Result entity.
// If the Result object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResultMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ResultMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetPrizeMap sets the "prize_map" field.
func (m *ResultMutation) SetPrizeMap(sm *schema.PrizeMap) {
	m.prize_map = &sm
}

// PrizeMap returns the value of the "prize_map" field in the mutation.
func (m *ResultMutation) PrizeMap() (r *schema.PrizeMap, exists bool) {
	v := m.prize_map
	if v == nil {
		return
	}
	return *v, true
}

// OldPrizeMap returns the old "prize_map" field's value of the Result entity.
// If the Result object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResultMutation) OldPrizeMap(ctx context.Context) (v *schema.PrizeMap, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrizeMap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrizeMap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrizeMap: %w", err)
	}
	return oldValue.PrizeMap, nil
}

// ResetPrizeMap resets all changes to the "prize_map" field.
func (m *ResultMutation) ResetPrizeMap() {
	m.prize_map = nil
}

// Where appends a list predicates to the ResultMutation builder.
func (m *ResultMutation) Where(ps ...predicate.Result) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Result, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Result).
func (m *ResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResultMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.province != nil {
		fields = append(fields, result.FieldProvince)
	}
	if m.created_time != nil {
		fields = append(fields, result.FieldCreatedTime)
	}
	if m.prize_map != nil {
		fields = append(fields, result.FieldPrizeMap)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case result.FieldProvince:
		return m.Province()
	case result.FieldCreatedTime:
		return m.CreatedTime()
	case result.FieldPrizeMap:
		return m.PrizeMap()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case result.FieldProvince:
		return m.OldProvince(ctx)
	case result.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case result.FieldPrizeMap:
		return m.OldPrizeMap(ctx)
	}
	return nil, fmt.Errorf("unknown Result field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case result.FieldProvince:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case result.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case result.FieldPrizeMap:
		v, ok := value.(*schema.PrizeMap)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrizeMap(v)
		return nil
	}
	return fmt.Errorf("unknown Result field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResultMutation) AddedFields() []string {
	var fields []string
	if m.addprovince != nil {
		fields = append(fields, result.FieldProvince)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case result.FieldProvince:
		return m.AddedProvince()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case result.FieldProvince:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProvince(v)
		return nil
	}
	return fmt.Errorf("unknown Result numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Result nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResultMutation) ResetField(name string) error {
	switch name {
	case result.FieldProvince:
		m.ResetProvince()
		return nil
	case result.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case result.FieldPrizeMap:
		m.ResetPrizeMap()
		return nil
	}
	return fmt.Errorf("unknown Result field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Result unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Result edge %s", name)
}

// SheetMutation represents an operation that mutates the Sheet nodes in the graph.
type SheetMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	status             *int64
	addstatus          *int64
	name               *string
	area               *int64
	addarea            *int64
	province           *int64
	addprovince        *int64
	ratio              *float64
	addratio           *float64
	result_time        *time.Time
	created_time       *time.Time
	updated_time       *time.Time
	user_id            *int64
	adduser_id         *int64
	clearedFields      map[string]struct{}
	records            map[int64]struct{}
	removedrecords     map[int64]struct{}
	clearedrecords     bool
	bet_setting        *int64
	clearedbet_setting bool
	done               bool
	oldValue           func(context.Context) (*Sheet, error)
	predicates         []predicate.Sheet
}

var _ ent.Mutation = (*SheetMutation)(nil)

// sheetOption allows management of the mutation configuration using functional options.
type sheetOption func(*SheetMutation)

// newSheetMutation creates new mutation for the Sheet entity.
func newSheetMutation(c config, op Op, opts ...sheetOption) *SheetMutation {
	m := &SheetMutation{
		config:        c,
		op:            op,
		typ:           TypeSheet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSheetID sets the ID field of the mutation.
func withSheetID(id int64) sheetOption {
	return func(m *SheetMutation) {
		var (
			err   error
			once  sync.Once
			value *Sheet
		)
		m.oldValue = func(ctx context.Context) (*Sheet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sheet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSheet sets the old Sheet of the mutation.
func withSheet(node *Sheet) sheetOption {
	return func(m *SheetMutation) {
		m.oldValue = func(context.Context) (*Sheet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SheetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SheetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Sheet entities.
func (m *SheetMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SheetMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SheetMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Sheet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *SheetMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SheetMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Sheet entity.
// If the Sheet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SheetMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SheetMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SheetMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *SheetMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *SheetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SheetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Sheet entity.
// If the Sheet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SheetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SheetMutation) ResetName() {
	m.name = nil
}

// SetArea sets the "area" field.
func (m *SheetMutation) SetArea(i int64) {
	m.area = &i
	m.addarea = nil
}

// Area returns the value of the "area" field in the mutation.
func (m *SheetMutation) Area() (r int64, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldArea returns the old "area" field's value of the Sheet entity.
// If the Sheet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SheetMutation) OldArea(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArea: %w", err)
	}
	return oldValue.Area, nil
}

// AddArea adds i to the "area" field.
func (m *SheetMutation) AddArea(i int64) {
	if m.addarea != nil {
		*m.addarea += i
	} else {
		m.addarea = &i
	}
}

// AddedArea returns the value that was added to the "area" field in this mutation.
func (m *SheetMutation) AddedArea() (r int64, exists bool) {
	v := m.addarea
	if v == nil {
		return
	}
	return *v, true
}

// ResetArea resets all changes to the "area" field.
func (m *SheetMutation) ResetArea() {
	m.area = nil
	m.addarea = nil
}

// SetProvince sets the "province" field.
func (m *SheetMutation) SetProvince(i int64) {
	m.province = &i
	m.addprovince = nil
}

// Province returns the value of the "province" field in the mutation.
func (m *SheetMutation) Province() (r int64, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the Sheet entity.
// If the Sheet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SheetMutation) OldProvince(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// AddProvince adds i to the "province" field.
func (m *SheetMutation) AddProvince(i int64) {
	if m.addprovince != nil {
		*m.addprovince += i
	} else {
		m.addprovince = &i
	}
}

// AddedProvince returns the value that was added to the "province" field in this mutation.
func (m *SheetMutation) AddedProvince() (r int64, exists bool) {
	v := m.addprovince
	if v == nil {
		return
	}
	return *v, true
}

// ResetProvince resets all changes to the "province" field.
func (m *SheetMutation) ResetProvince() {
	m.province = nil
	m.addprovince = nil
}

// SetRatio sets the "ratio" field.
func (m *SheetMutation) SetRatio(f float64) {
	m.ratio = &f
	m.addratio = nil
}

// Ratio returns the value of the "ratio" field in the mutation.
func (m *SheetMutation) Ratio() (r float64, exists bool) {
	v := m.ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldRatio returns the old "ratio" field's value of the Sheet entity.
// If the Sheet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SheetMutation) OldRatio(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatio: %w", err)
	}
	return oldValue.Ratio, nil
}

// AddRatio adds f to the "ratio" field.
func (m *SheetMutation) AddRatio(f float64) {
	if m.addratio != nil {
		*m.addratio += f
	} else {
		m.addratio = &f
	}
}

// AddedRatio returns the value that was added to the "ratio" field in this mutation.
func (m *SheetMutation) AddedRatio() (r float64, exists bool) {
	v := m.addratio
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatio resets all changes to the "ratio" field.
func (m *SheetMutation) ResetRatio() {
	m.ratio = nil
	m.addratio = nil
}

// SetResultTime sets the "result_time" field.
func (m *SheetMutation) SetResultTime(t time.Time) {
	m.result_time = &t
}

// ResultTime returns the value of the "result_time" field in the mutation.
func (m *SheetMutation) ResultTime() (r time.Time, exists bool) {
	v := m.result_time
	if v == nil {
		return
	}
	return *v, true
}

// OldResultTime returns the old "result_time" field's value of the Sheet entity.
// If the Sheet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SheetMutation) OldResultTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultTime: %w", err)
	}
	return oldValue.ResultTime, nil
}

// ResetResultTime resets all changes to the "result_time" field.
func (m *SheetMutation) ResetResultTime() {
	m.result_time = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *SheetMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *SheetMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Sheet entity.
// If the Sheet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SheetMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *SheetMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *SheetMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *SheetMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the Sheet entity.
// If the Sheet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SheetMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *SheetMutation) ResetUpdatedTime() {
	m.updated_time = nil
}

// SetUserID sets the "user_id" field.
func (m *SheetMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SheetMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Sheet entity.
// If the Sheet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SheetMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *SheetMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *SheetMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SheetMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// AddRecordIDs adds the "records" edge to the Record entity by ids.
func (m *SheetMutation) AddRecordIDs(ids ...int64) {
	if m.records == nil {
		m.records = make(map[int64]struct{})
	}
	for i := range ids {
		m.records[ids[i]] = struct{}{}
	}
}

// ClearRecords clears the "records" edge to the Record entity.
func (m *SheetMutation) ClearRecords() {
	m.clearedrecords = true
}

// RecordsCleared reports if the "records" edge to the Record entity was cleared.
func (m *SheetMutation) RecordsCleared() bool {
	return m.clearedrecords
}

// RemoveRecordIDs removes the "records" edge to the Record entity by IDs.
func (m *SheetMutation) RemoveRecordIDs(ids ...int64) {
	if m.removedrecords == nil {
		m.removedrecords = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.records, ids[i])
		m.removedrecords[ids[i]] = struct{}{}
	}
}

// RemovedRecords returns the removed IDs of the "records" edge to the Record entity.
func (m *SheetMutation) RemovedRecordsIDs() (ids []int64) {
	for id := range m.removedrecords {
		ids = append(ids, id)
	}
	return
}

// RecordsIDs returns the "records" edge IDs in the mutation.
func (m *SheetMutation) RecordsIDs() (ids []int64) {
	for id := range m.records {
		ids = append(ids, id)
	}
	return
}

// ResetRecords resets all changes to the "records" edge.
func (m *SheetMutation) ResetRecords() {
	m.records = nil
	m.clearedrecords = false
	m.removedrecords = nil
}

// SetBetSettingID sets the "bet_setting" edge to the BetSetting entity by id.
func (m *SheetMutation) SetBetSettingID(id int64) {
	m.bet_setting = &id
}

// ClearBetSetting clears the "bet_setting" edge to the BetSetting entity.
func (m *SheetMutation) ClearBetSetting() {
	m.clearedbet_setting = true
}

// BetSettingCleared reports if the "bet_setting" edge to the BetSetting entity was cleared.
func (m *SheetMutation) BetSettingCleared() bool {
	return m.clearedbet_setting
}

// BetSettingID returns the "bet_setting" edge ID in the mutation.
func (m *SheetMutation) BetSettingID() (id int64, exists bool) {
	if m.bet_setting != nil {
		return *m.bet_setting, true
	}
	return
}

// BetSettingIDs returns the "bet_setting" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BetSettingID instead. It exists only for internal usage by the builders.
func (m *SheetMutation) BetSettingIDs() (ids []int64) {
	if id := m.bet_setting; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBetSetting resets all changes to the "bet_setting" edge.
func (m *SheetMutation) ResetBetSetting() {
	m.bet_setting = nil
	m.clearedbet_setting = false
}

// Where appends a list predicates to the SheetMutation builder.
func (m *SheetMutation) Where(ps ...predicate.Sheet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SheetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SheetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Sheet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SheetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SheetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Sheet).
func (m *SheetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SheetMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.status != nil {
		fields = append(fields, sheet.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, sheet.FieldName)
	}
	if m.area != nil {
		fields = append(fields, sheet.FieldArea)
	}
	if m.province != nil {
		fields = append(fields, sheet.FieldProvince)
	}
	if m.ratio != nil {
		fields = append(fields, sheet.FieldRatio)
	}
	if m.result_time != nil {
		fields = append(fields, sheet.FieldResultTime)
	}
	if m.created_time != nil {
		fields = append(fields, sheet.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, sheet.FieldUpdatedTime)
	}
	if m.user_id != nil {
		fields = append(fields, sheet.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SheetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sheet.FieldStatus:
		return m.Status()
	case sheet.FieldName:
		return m.Name()
	case sheet.FieldArea:
		return m.Area()
	case sheet.FieldProvince:
		return m.Province()
	case sheet.FieldRatio:
		return m.Ratio()
	case sheet.FieldResultTime:
		return m.ResultTime()
	case sheet.FieldCreatedTime:
		return m.CreatedTime()
	case sheet.FieldUpdatedTime:
		return m.UpdatedTime()
	case sheet.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SheetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sheet.FieldStatus:
		return m.OldStatus(ctx)
	case sheet.FieldName:
		return m.OldName(ctx)
	case sheet.FieldArea:
		return m.OldArea(ctx)
	case sheet.FieldProvince:
		return m.OldProvince(ctx)
	case sheet.FieldRatio:
		return m.OldRatio(ctx)
	case sheet.FieldResultTime:
		return m.OldResultTime(ctx)
	case sheet.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case sheet.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	case sheet.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Sheet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SheetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sheet.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sheet.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sheet.FieldArea:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArea(v)
		return nil
	case sheet.FieldProvince:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case sheet.FieldRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatio(v)
		return nil
	case sheet.FieldResultTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultTime(v)
		return nil
	case sheet.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case sheet.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	case sheet.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Sheet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SheetMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, sheet.FieldStatus)
	}
	if m.addarea != nil {
		fields = append(fields, sheet.FieldArea)
	}
	if m.addprovince != nil {
		fields = append(fields, sheet.FieldProvince)
	}
	if m.addratio != nil {
		fields = append(fields, sheet.FieldRatio)
	}
	if m.adduser_id != nil {
		fields = append(fields, sheet.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SheetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sheet.FieldStatus:
		return m.AddedStatus()
	case sheet.FieldArea:
		return m.AddedArea()
	case sheet.FieldProvince:
		return m.AddedProvince()
	case sheet.FieldRatio:
		return m.AddedRatio()
	case sheet.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SheetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sheet.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case sheet.FieldArea:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArea(v)
		return nil
	case sheet.FieldProvince:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProvince(v)
		return nil
	case sheet.FieldRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatio(v)
		return nil
	case sheet.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Sheet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SheetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SheetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SheetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Sheet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SheetMutation) ResetField(name string) error {
	switch name {
	case sheet.FieldStatus:
		m.ResetStatus()
		return nil
	case sheet.FieldName:
		m.ResetName()
		return nil
	case sheet.FieldArea:
		m.ResetArea()
		return nil
	case sheet.FieldProvince:
		m.ResetProvince()
		return nil
	case sheet.FieldRatio:
		m.ResetRatio()
		return nil
	case sheet.FieldResultTime:
		m.ResetResultTime()
		return nil
	case sheet.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case sheet.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	case sheet.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Sheet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SheetMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.records != nil {
		edges = append(edges, sheet.EdgeRecords)
	}
	if m.bet_setting != nil {
		edges = append(edges, sheet.EdgeBetSetting)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SheetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sheet.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.records))
		for id := range m.records {
			ids = append(ids, id)
		}
		return ids
	case sheet.EdgeBetSetting:
		if id := m.bet_setting; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SheetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrecords != nil {
		edges = append(edges, sheet.EdgeRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SheetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sheet.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.removedrecords))
		for id := range m.removedrecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SheetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrecords {
		edges = append(edges, sheet.EdgeRecords)
	}
	if m.clearedbet_setting {
		edges = append(edges, sheet.EdgeBetSetting)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SheetMutation) EdgeCleared(name string) bool {
	switch name {
	case sheet.EdgeRecords:
		return m.clearedrecords
	case sheet.EdgeBetSetting:
		return m.clearedbet_setting
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SheetMutation) ClearEdge(name string) error {
	switch name {
	case sheet.EdgeBetSetting:
		m.ClearBetSetting()
		return nil
	}
	return fmt.Errorf("unknown Sheet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SheetMutation) ResetEdge(name string) error {
	switch name {
	case sheet.EdgeRecords:
		m.ResetRecords()
		return nil
	case sheet.EdgeBetSetting:
		m.ResetBetSetting()
		return nil
	}
	return fmt.Errorf("unknown Sheet edge %s", name)
}
